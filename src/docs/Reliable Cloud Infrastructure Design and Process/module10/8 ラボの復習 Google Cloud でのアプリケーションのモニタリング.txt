このラボではGoogle Cloudツールを使い、アプリのモニタリングを学びました
まず、アプリをApp Engineにデプロイしてログを確認し、次にプロファイル情報を表示し、Cloud Traceを使いました
最後にダッシュボードでアプリをモニタリングし、稼働時間チェックとアラートを作成しました
ラボは引き続き利用できますが、UIが変更されることがあるのでご注意ください
まず、Cloud Shellをアクティブにし、GitHubからサンプルアプリをダウンロードします
新しいプロジェクトなので、[続行]をクリックします
広く表示されるよう、新しいウィンドウで開きます
プリインストール関連のメッセージです
マシンがプロビジョニングされるまで待ちます
ディレクトリを作成し、そのディレクトリに移動して、GitHubからPython Flaskアプリのクローンを作成します
ディレクトリを作成して、そのディレクトリに移動します
前のラボと同じリポジトリから、クローンを作成します
完了したら、ディレクトリに移動してエディタも起動します
次は、coursesのdesign-processからこのアプリに移動します
mainファイルが表示されます
このmainファイルに変更を加えます
Google Cloud Profilerを使うためです
２行目でプロファイラ読み込みを指定します
これにより、アプリが使用するリソースをプロファイラでモニタリングできます
main関数の後に、プロファイラを起動するコードスニペットを追加します
下の方の13行目に追加しましょう
これでプロファイラが起動されます
入力したコードが、ラボの指定と一致していることを確認します
問題ないですね
このコードによって起動されたプロファイラは、Google Cloudにアプリ指標の報告を開始します
次に、プロファイラをプロファイルライブラリにも追加します
requirements.txtです
やってみましょう
requirements.txtを開いて、２行目でGoogle Cloud Profilerの使用を指定します
できました
最後にプロジェクトで、プロファイラを有効にします
これはCloud Shellで行います
clearでスペースを確保しましょう
ラボの手順にあるコマンドを実行して、Google APIからCloud Profilerを有効にします
完了したら、プログラムをテストします
まずrequirementsをインストールして、プログラムを開始します
Google Profilerのビルドが確認できたので、テストしてみましょう
Cloud Shellの[ウェブでプレビュー]を使用して、ポート8080でプレビューします
プログラムが正常に動作して、“Hello GCP.”と表示されました
これでタスク１は終了です
タスク２では、このアプリをApp Engineアプリにデプロイします
Cloud Shellに戻って、実行中のコマンドを停止します
新しいapp.yamlファイルを作成します
このフォルダを右クリックして、[New File]を選択し、app.yamlと入力します
少なくともランタイムを指定する必要があるので、Pythonを指定して変更を保存します
次に、アプリのリージョンを指定します
gcloud app create --region=us-central1を使用します
このリージョンにプロジェクトのアプリが作成されます
アプリが起動したらデプロイします
デプロイが完了するまで待ちます
アプリがデプロイされたので、Cloud Consoleで確認しましょう
Cloud Consoleに移動して、ナビゲーションメニューでApp Engineにアクセスします
折りたたんで確認すると、現在はバージョンがひとつだけ存在し、ここにアプリがあります
アプリのURLをクリックすると、先ほどと同じように“Hello GCP.”と表示されます
何度か更新するとトラフィックを生成できますが、これはプロファイラの説明時に行います
先にタスク３に進んでログを確認しましょう
App Engineに戻って、[バージョン]をクリックします
このバージョンが、全トラフィックを処理しています
右側にある[診断]の[ツール]で[ログ]を選択します
過去のリクエストが表示され、Stackdriverプロファイラが起動してプロファイルを作成したこともわかります
成功していますね
では、タスク４に進んでプロファイル情報を表示しましょう
ナビゲーションメニューの[オペレーション]で[プロファイラ]をクリックします
灰色のバーは、プログラムが使用した総CPU時間、その下のバーは全体のうちプログラムの関数が使用したCPU時間です
現時点ではトラフィックがないため、グラフが単調です
これから、アプリに一定の負荷をかけるために、App Engineアプリとは違うリージョンのCompute Engineを使用して、仮想マシンを作成し、ベンチを使ってトラフィックを発生させます
ナビゲーションメニューからCompute Engineにアクセスし、[作成]をクリックします
別のリージョンを選択するので、us-central1ではなくeurope-north1を指定します
[作成]をクリックします
仮想マシンが起動したら、このインスタンスにSSH接続します
sudo apt updateを実行してから、install apache2-utilsも実行します
SSHにアクセスします
ウィンドウのサイズを少し変えて、コマンドを実行したらApache Benchでトラフィックを生成します
まず更新して、Apache Benchをインストールします
次にApache Benchコマンドを1,000回実行します
同時リクエスト数は10です
ただし、App EngineアプリのHTTPSアドレスが必要です
これはデフォルトで常に<プロジェクトID>.appsbot.comの形式です
アドレスを入力するか、ブラウザからコピーして貼り付けます
必ず末尾にスラッシュを付けてください
では実行しましょう
トラフィックを生成するために数回実行します
プロファイラに情報が表示されるまでに、しばらくかかる場合がありますが、十分なトラフィックを生成すればより興味深いグラフができるので何度か実行してください
前述したように、グラフには関数を表すバーが表示され、バーの幅は各関数で使用されたCPU時間を表します
もう少しトラフィックを生成します
プロファイラを確認してから、タスク５に移ります
トラフィックがある程度生成されたので、Cloud Consoleに戻って、ナビゲーションメニューからプロファイラにアクセスします
情報が増えました
バーは関数を表し、バーの幅はプログラムが各関数で使用したCPU時間を表します
これでタスク４は終了です
タスク５ではCloud Traceを使います
アプリへのリクエストはすべてトレースリストに追加されます
ナビゲーションメニューの[オペレーション]で[トレース]をクリックします
最近のリクエストが表示される[概要]の画面です
レポートを作成して、トラフィックを分析できます
プログラムが新しいため情報が少ないですが、実際のアプリでは役立つ情報が多数表示されます
[トレースリスト]をクリックすると、リクエストの履歴とレイテンシが表示されます
数分前に行った複数のリクエストがすべて表示されています
一部でレイテンシが若干高いことがわかります
ここでも確認できます
レイテンシがありますね
では、仮想マシンのSSHウィンドウに戻りましょう
さらにトラフィックを生成してから、もう一度トレースリストを確認します
Apache Benchコマンドを追加で実行しましたが、実は値を変えていました
nとcの値を変えて試すことができます
同時に100回で計10,000回リクエストしています
移動してトレースリストを再読み込みします
同時リクエスト数がかなり多いので、多数のリクエストが表示されています
レイテンシが高いものもあります
いろいろと試してみてください
長くなりましたが、メインはトレースとトレースリストの使用方法についての説明です
タスク６に進み、ダッシュボードを使ってリソースをモニタリングします
Cloud Consoleで[Monitoring]に移動します
[オペレーション]にあります
最初にワークスペースが構築されます
ワークスペースの構築が完了するとウェルカムページが表示されるので、左側のナビゲーションバーを使用してダッシュボードに移動します
リソースが表示されています
GCEインスタンスが表示されていないので、更新後に再度確認します
App Engineに移動します
プロジェクトとアプリが表示されています
これをクリックすると、アプリのダッシュボードが表示されます
HTTPレスポンスだけでなく、[システム]や[データストア]などさまざまな項目を確認できます
カスタムダッシュボードの作成も可能です
ダッシュボードに戻って、[ダッシュボードを作成]をクリックし、名前を付けます
GCEインスタンスがないので作成しましょう
ダッシュボードにグラフを追加できます
GCE VMインスタンスを探します
指標としてCPU使用率を選択します
インスタンスが追加され、ここに示されています
Apache Benchコマンドがインスタンスにかけた負荷がわかります
コマンド実行時に使用率が高まっているのが明らかです
フィルタやグループも指定して保存でき、グラフも表示できます
このように、CPU使用率を確認できるようになります
他のグラフを作成することもできます
タスク６は以上です
タスク７に進んで、稼働時間チェックとアラートを作成しましょう
左側にある[稼働時間チェック]をクリックし、[稼働時間チェックの作成]をクリックします
名前を付けます
App Engineアプリ用に作成しましょう
[Check Type]は[HTTPS]、[Resource Type]は[URL]です
ホスト名を入力するために、アプリを実行しているブラウザに戻り、コピーして貼り付けます
HTTPSは指定してあります
パスも指定してこれは削除します
[Check every]は[1 minute]のままにしてテストします
レスポンスが返されました
問題ありません
保存します
稼働時間チェック作成完了のメッセージが表示されます
アラートポリシーも作成すると便利です
アプリのダウンタイムが発生した場合に、稼働時間チェックを見ていなくてもポリシーを作成していれば通知が届きます
ポリシーを作成しましょう
稼働時間チェックがすでに指定されています
稼働時間チェックが指標そのものであり、条件です
名前を指定します
My Uptime Alertにしましょうか
いえ、ラボと同じUptime Check Alertとしましょう
ラボのスコアに影響しますので、手順どおりに進めてください
できました
これが指標です
そしてこれが条件の名前でしたね
同じ名前を使いましょう
条件は複数指定できるので、他に問題が発生したときにOR条件かAND条件でトリガーするよう設定できます
必須ではありませんが重要なのが、通知チャネルの追加です
さまざまな種類から選択できます
たとえばメールです
自分のメールアドレスも指定できますが、あまりおすすめしません
テストを行うと、プロジェクトを削除するまでアプリは停止しないので、大量のメールが届く可能性があります
ここではこのQwiklabsプロジェクトのメールアドレスを入力し、追加します
もうひとつ重要なのは、ドキュメントの入力です
メールの受信者がどう対処すべきかや実際の具体的な障害計画を示します
たとえば、“アプリが停止した場合、xyzを行って担当者に連絡”など自由に入力してください
今回はこのまま保存してスコアを確認します
次は、このアプリを無効にして、稼働時間チェックが失敗することを確認します
確認してみると、現在はすべての大陸で稼働時間チェックが機能しています
名前をクリックすると詳細情報が表示されます
今のところ稼働時間100%です
レイテンシも表示されています
リージョンごとに詳細を確認することも可能です
複数のリージョンで、テストされていることがわかります
具体的には、これらの大陸のさまざまなリージョンが対象です
各設定をまとめて確認できます
アラートポリシーの有無の確認や、ポリシーの作成も可能です
アプリを無効にする手順にうつります
ナビゲーションメニューを使って、App Engineに戻ります
下にスクロールして[設定]をクリックします
[アプリケーションを無効にする]をクリックします
セキュリティ上の理由から、名前の入力を求められるのでアプリIDを入力して、[無効にする]をクリックします
これで無効になりました
ダッシュボードに戻って、URLをクリックすると404エラーが表示されます
これが再現したかったことです
ナビゲーションメニューで[Monitoring]に戻り、稼働時間チェックを行います
チェックが再実行されるまで待ちます
１分ごとに実行されるので、次は失敗するはずです
失敗しましたね
欧州で失敗しています
こちらは３つのうち１つのテストが失敗です
いったん切り替えて稼働時間チェックに戻すと、北米と南米ですべてのテストが失敗しています
残るはアジア太平洋だけです
稼働率が過去１時間で下がっています
apac-singaporeが最後のリージョンです
更新すると、すべて失敗しました
アラートに移動すると、アラートポリシーがトリガーされています
まさに今も定義したアラート送信条件に応じて、実際にアラートが送信されているはずです
自分のメールアドレスを入力した場合は、アラートが届きます
何度か更新して確認します
インシデントの失敗を実際に確認するか、アラートを受け取ったらこのアラートの通知チャネルを編集してメールアドレスを削除することをおすすめします
削除しておけば、このアラートに関するメールが今後届くことはありません
チェックは失敗し続けるので、アラートも送信され続けます
[EDIT]を選択して、メールアドレス横のゴミ箱アイコンをクリックし、[SAVE]をクリックします
稼働時間チェック自体も削除しておきましょう
これでもう通知が届かなくなります
以上です
