前のモジュールでは取り上げなかった、ネットワークセキュリティの概念を確認しましょう
ネットワーク外部からのアクセスを防ぐために、可能な限りマシンの外部IPを削除してください
パブリックIPのないVMと安全に通信するには、いくつかの方法があります
パブリックIPのないVMは、プロジェクト内だけで使用する目的でデプロイされているか、Dedicated Interconnectを使っています
ただし、外部IPのないVMにも外部へのアクセスが必要になる場合があります
たとえば更新やパッチ適用のためです
その場合のアクセス方法には、外部から非公開マシンにアクセスする踏み台インスタンス、SSHアクセスを有効にするIdentity-Aware Proxy、内部マシンのインターネットアクセスを可能にするCloud NATがあります
右側の図では、外部クライアントが踏み台インスタンス経由でGCEリソースにアクセスしています
ホストへのアクセスはファイアウォールで、制限できます
いずれの方法でも、インターネットトラフィックをロードバランサ、ファイアウォール、API Gatewayで終了させるか、Cloud IAPを使用すれば内部サービスを起動してパブリックIPを取得することを防げます
内部IPしかないVMでも、限定公開のGoogleアクセスを使用すれば外部IPを持つGoogleサービスにアクセスできます
右側の図に示すGCEインスタンスは、自身の内部IPを使ってStorageバケットにアクセスしています
このアクセス機能は、サブネットの作成時に有効にしてください
有効にするにはここに示すgcloudコマンドか、Cloud Consoleを使用します
VMにパブリックIPがあるかどうかにかかわらず、ファイアウォールルールでアクセスを制御してください
既定ではすべてのポートで内向きが拒否され、すべての外向きが許可されます
特定インスタンスに対する、特定のIP範囲、プロトコル、ポートでのアクセスを許可または拒否するルールは、お客様が別途定義してください
この図はファイアウォールルールを構成するシナリオを示しています
最初のシナリオはCompute Engineから、外部サーバーへの外向きです
内向きのファイアウォールルールが必要となるのは、インスタンスに直接またはロードバランサ経由でアクセスできる場合です
右側の図は、VMインスタンス間の通信のシナリオを示しています
この場合もファイアウォールルールによる制御を検討します
各アプリのセキュリティは、お客様の責任で確保してください
APIを管理するには、Cloud Endpointsを使用できます
EndpointsはAPI管理ゲートウェイとして、任意のGoogle CloudバックエンドでのAPIの開発、デプロイ、管理を支援します
Endpointsを使用すると、公開APIの保護とモニタリングやAuth0などを使用したユーザーアクセスの制御、サービスアカウントの秘密鍵で署名されたJSON Web Tokenでの呼び出し検証を行えます
認証に対応するために、Identity Platformも統合されています
どのCloudサービスエンドポイントも、HTTPSを使用します
お客様のサービスエンドポイントには、TLSを推奨します
TLS対応サービスエンドポイントの構成は、お客様の責任となります
ロードバランサの構成で、フロントエンドの安全を確保してください
このダイアログに示すフロントエンドの構成では、プロトコルとしてHTTPSが選択され、証明書も選択されています
Googleはグローバルロードバランサを介し、レベル３と４のトラフィックでインフラのDDoS対策を提供します
CDNを有効にしていれば、バックエンドリソースも保護されます
右側に示すようにDDoSはキャッシュヒットとなり、リソースに到達できないからです
Cloud Armorには、ネットワークのモジュールで触れました
組み込みのDDoS対策を強化する追加機能として、Armorでネットワーク、セキュリティポリシーを作成できます
たとえば許可リストを作成して、既知または必要なアドレスを許可し、拒否リストで既知の攻撃者をブロックできます
この図に示すように、一般的なセキュリティポリシー構成では、まずルールに対して[許可]か[拒否]を選択して許可リスト/拒否リストを構成します
拒否する場合、この例での適切なアクションは403エラーです
レイヤ３と４のセキュリティに加えて、Cloud Armorはレイヤ７のアプリルールもサポートします
たとえばXSSやSQLインジェクション攻撃に対するルールが事前に定義されています
Cloud Armorではルール言語を使用して、リクエストトラフィックをフィルタできます
例として、このスライドの最初の式について考えましょう
inIpRange(origin.ip,'9.9.9.0/24')です
この場合、リクエスト内の送信元IPが9.9.9.0/24の範囲内であれば、式がtrueを返します
２行目のrequest.headers['cookie'].contains('80=BLAH')は、リクエストヘッダー内に値がBLAHのCookie 80が存在する場合はtrueを返し、３行目は送信元の地域コードがAUの場合はtrueを返します
論理ANDや論理ORを使用して、論理的に式を組み合わせることも可能です
すべての式が、受信トラフィックに適用される許可または拒否のルールに割り当てられます
