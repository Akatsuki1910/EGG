継続的インテグレーション（CI）、パイプラインの概要です
CIパイプラインは、アプリの構築を自動化するものです
ここに示すのは大まかなパイプラインです
実際には要件に応じてカスタマイズします
まず、リポジトリにコードをチェックインすると単体テストが実施されます
テストに合格すると、デプロイパッケージがDockerイメージとしてビルドされます
イメージはContainer Registryに保存され、そこからデプロイできるようになります
マイクロサービスごとに個別のリポジトリが必要です
追加の手順としてよくあるのはコードのlintチェック、SonarQubeなどのツールによる品質分析、インテグレーションテスト、テストレポート作成、イメージスキャンなどです
Google Cloudには、CIパイプラインの構築に必要なコンポーネントが揃っています
それぞれを見ていきましょう
Cloud Source Repositoryサービスは、Google Cloud上でGitリポジトリを提供します
これらのリポジトリを使えば、アプリやサービスの開発、デプロイをコードの共同作業やバージョン管理が可能なスペースで行えます
Cloud Source RepositoriesはGoogle Cloudに統合されているため、シームレスな開発作業が可能です
Cloud Buildは、Google Cloudインフラでビルドを実行します
ソースコードはCloud Storage Source Repositories、GitHub、Bitbucketからインポートできます
ユーザーの指定に従ってビルドが実行され、DockerコンテナやJavaアーカイブなどのアーティファクトが生成されます
Cloud Buildは、一連のビルドステップとしてビルドを実行します
各ビルドステップは、Dockerコンテナで実行されます
各ビルドステップではコンテナで実行できるあらゆる処理が行えます
環境の違いには左右されません
標準的なステップはありますが、独自のステップも定義できます
ソースコードを変更するたびに、Cloud Buildトリガーが自動的にビルドを開始します
ソースリポジトリが変更された場合や、特定の条件に一致する変更があった場合にコードをビルドするようにトリガーを構成できます
Container Registryでは、Dockerイメージやデプロイパッケージを一元管理し、脆弱性分析を行い、どのユーザーが何にアクセスできるのかをきめ細かく制御できます
各サービスをさらに詳しく見ていきましょう
Cloud Source RepositoriesはマネージドGitリポジトリを提供します
Cloud IAMを使用して、プロジェクトにチームメンバーを追加し、メンバーにリポジトリの作成、表示、更新の権限を付与できます
リポジトリを構成して指定のPub/Subトピックにメッセージをパブリッシュすることもできます
リポジトリの作成、削除、またはcommitのpushが行われたときに、メッセージをパブリッシュできます
Cloud Source Repositoriesにはその他に、Cloudデバッガを使用した本番環境でのデバッグ機能、いつ、どこで、どのアクションが行われたかを把握するための監査ログ機能、App Engineへの直接デプロイ機能があります
既存のGitHubやBitbucketのリポジトリをCloud Source Repositoriesに接続することもできます
接続されたリポジトリは自動的にCloud Source Repositoriesと同期されます
Cloud Buildでは、どの言語でもソフトウェアを迅速にビルドできます
これはGoogleがホストするDockerビルドサービスであり、Dockerビルドの代わりに使用されます
CLIでgcloudを使用してビルドをサブミットできます
このスライドに一例として示しているgcloud builds submitは、ビルドをサブミットしてリモートビルドとして実行します
--tagではイメージの作成に使用するタグを指定します
このタグにはgcr.io名前空間か、start.gcr.io.start名前空間を使う必要があります
このタグを使う場合は、ソースにDockerfileが含まれている必要があります
末尾のドットは、ビルド対象のソースがある場所を表します
ビルドトリガーはリポジトリを監視し、コードがpushされるたびにコンテナをビルドします
GoogleのビルドトリガーはMaven、Cloud Build、Dockerをサポートします
Cloud Buildトリガーはソースコードが変更されるたびに自動的にビルドを開始します
特定のブランチに対するcommit、または特定のタグを含むcommitと同時にビルドを開始するように設定できます
照合するブランチまたはタグの値には正規表現を指定できます
ビルド構成は、DockerfileまたはCloud Buildファイルで指定できます
必要な構成をスライドに示しています
まず、ソースを選択します
Cloud Source Repositories、GitHub、Bitbucketを選択できます
次のステージではソースリポジトリを選択し、その後にトリガーを設定します
トリガーの設定には、トリガーに使用するブランチやタグなどの情報と、DockerfileやCloud Buildファイルなどのビルド構成が含まれます
Container RegistryはGoogle CloudがホストするDockerリポジトリです
Cloud Buildでビルドされたイメージは自動的にこのリポジトリに保存されます
イメージは、このスライドに示す接頭辞でタグ付けされます
標準的なDockerコマンドを使用してイメージをpush、pullすることもできます
イメージをpushするには、docker push gcr.io/（プロジェクトID）/（イメージ名）を使用します
イメージをpullするには、docker pull gcr.io/（プロジェクトID）/（イメージ名）を使用します
Binary Authorizationを使うと、信頼できるコンテナのみをGKEにデプロイするように強制できます
Binary Authorizationは、Kritis仕様に基づくGoogle Cloudサービスです
この仕組みを機能させるには、デプロイを実施するGKEクラスタでBinary Authorizationを有効にします
イメージに署名する際のポリシーも必要です
イメージがCloud Buildでビルドされると、そのイメージがSource Repositoriesなどの信頼できるリポジトリに属することを認証者が検証します
Container Registryにはコンテナをスキャンする脆弱性スキャナが含まれます
図に標準的なワークフローを示しています
コードチェックインで、Cloud Buildが起動します
ビルドの一環としてContainer Registryが、新しくアップされたイメージの脆弱性スキャンを行います
スキャナはメッセージをPub/Subにパブリッシュします
Kritis SignerはContainer Registry脆弱性スキャナからのPub/Sub通知をリッスンし、イメージスキャンが脆弱性スキャンに合格すると証明書を作成します
するとBinary Authorizationサービスで、Kritis Signerによる証明書を要求するポリシーが適用されてから、コンテナイメージがデプロイ可能になります
このフローにより、特定のしきい値を下回る脆弱性を持つイメージのデプロイが防止されます
