このラボではアプリをApp Engine、GKE、Cloud Runにデプロイする方法を確認しました
各プラットフォームを実際に操作してみて、独自のサービスに適したプラットフォームを判断する参考になったことを願います
このコースで学習したTwelve-Factorのベストプラクティスをおすすめします
可能な限り継続的インテグレーションとIaCツールを使って自動化し、Dockerでサービスをコンテナ化してください
こうするとアプリのポータビリティが向上し、どのコンピューティングプラットフォームでも簡単かつ柔軟にデプロイできます
これからラボのチュートリアルを行いますが、Google CloudのUIは変更されることがあるので実際の環境と表示が異なる場合があります
まずCloud ConsoleでCloud Shellをアクティブにします
新規プロジェクトの場合は、[続行]をクリックします
Shellを新しいウィンドウで開きます
これからディレクトリを作成して、そこに移動し用意されているGitHubリポジトリを複製します
ディレクトリを作成します
作成したディレクトリに移動します
GitHubリポジトリを複製します
この一般公開のリポジトリは、他の多くのコースでも使用します
実際に開発に貢献できるという利点があります
問題の修正や機能の強化に役立つ変更点を見つけたら、pullリクエストを行うことができます
複製されました
複製が完了したら、作成されたフォルダに移動します
そのフォルダ内にあるプログラムをテストします
Python Flaskアプリです
そこに移動します
次に、アプリを起動します
実行中です
ポート8080で実行中とあります
Cloud Shellのプレビューアイコンで実際の表示を確認できます
“Hello GCP.”と表示されます
どこかにこのテキストを定義しているファイルがあります
画面を閉じます
この最初のステップではアプリの確認のみを行いました
次は、このアプリをApp Engine、GKE、Cloud Runにデプロイして、これらのサービス間での相違点と類似点を確認します
最初はApp Engineです
エディタを開いて、app.yamlというファイルを作成します
このファイルでランタイムを定義します
App Engineは複数の言語で稼働し、Python、JavaScript、Goに対応します
定義するために“courses”を展開して、Shellの作業ディレクトリと同じ“design-process”に移動します
ちなみに、テキスト“Hello GCP.”はmain.pyに定義されています
このフォルダ内に新しいファイルを作成し、“app.yaml”と名付けます
このファイル内でランタイムを定義します
ここには他の設定も指定できますが、この例では言語ランタイムの設定が必須です
[File]、[Save]をクリックします
画面を少し大きくして見やすくします
次に実行するgcloud app createコマンドでは、アプリを作成するリージョンの指定が必要です
手順に従ってus-centralを指定します
プロジェクトが指定されていないとあります
このエラーは学習に役立つので対処しましょう
現在、プロジェクトプロパティが空の文字列に設定されているため無効だとあります
gcloud config set projectコマンドを実行するよう指示されています
実行しましょう
プロジェクトIDをコピーするために、Cloud Consoleに移動します
ここでコピーできます
QwiklabsのUIからコピーすることもできます
IDをここに設定します
更新したら、このコマンドを再実行します
今回は、App Engineアプリが指定したプロジェクトとリージョンで作成中になりました
作成されたら、このアプリをデプロイします
このバージョンを“one”と名付けましょう
処理が完了するまで数分待ってから、App Engineに移動してこのプログラムをテストします
コマンドが完了しました
Cloud Consoleに移動するためにタブを切り替えます
App Engineに移動します
ナビゲーションメニューで、[App Engine]を選択します
スペースを空けるために、このパネルを非表示にします
ダッシュボードにトラフィックを処理中のバージョン“one”が示されています
このリンクはちなみに、デフォルトでは常にプロジェクトIDの後にappspot.comが続くHTTPS形式のURLになります
このリンクをクリックします
“Hello GCP.”と表示されて、App Engineで実行中であることを確認できます
次はプログラムに変更を加えて、App Engineでいかに簡単にバージョン管理できるか確認しましょう
Cloud Shellに戻ります
前述のとおり、main.pyファイルに“Hello GCP.”が設定されています
これを“Hello App Engine.”に変更します
変更したら保存します
変更後は再デプロイする必要があります
既存のバージョンを上書きするのではなく、新しいバージョンを作成しましょう
コマンドgcloud app deploy --version=twoを実行します
“no promote”パラメータを使って、App Engineに引き続き古いバージョン“one”でリクエストを処理するよう指示します
こうすると、新しいバージョンをテストしてから本番環境に移行できます
処理の完了を待ちましょう
完了しました
タブを切り替えてアプリを再表示し、更新ボタンをクリックするとまだ“Hello GCP.”と表示されます
現在トラフィックを処理しているのはバージョン“one”だからです
詳しく調べるためにApp Engineに戻ります
具体的には[ダッシュボード]です
左側にある[バージョン]をクリックします
更新すると、２つのバージョンが表示されますが、全トラフィックを処理しているのは今でもバージョン“one”です
これから新しいバージョンをテストして、問題がないことを確認してからトラフィックを移行できます
バージョン“two”をクリックしてテストします
“Hello App Engine.”と表示されます
この単純なアプリでさらにテストすることもできますが、今回はこれで十分なので[バージョン]に戻ります
“トラフィックを分割”をクリックします
トラフィックを“two”に割り当てます
分割の基準を[IPアドレス]、[Cookie]、[ランダム]から選択できます
[保存]をクリックして、このバージョンがトラフィックの100%を受信するようにします
バージョンを追加すれば実際に分割できますが、この例ではバージョン“two”で全トラフィックを処理します
処理が完了するまでに１、２分かかります
完了すると、正常に保存されたというメッセージが表示されるので、元の画面に戻ります
すべてのトラフィックが移行されています
確認できたので[ダッシュボード]に戻って、リンクをクリックすると“Hello App Engine.”と表示されます
App Engineでのデプロイが完了したので、次はこのアプリをGKEにデプロイします
GKEではマシンのクラスタを作成して、任意の数のアプリをクラスタにデプロイできます
作業を進める前に、タブをいくつか閉じてスペースを空けます
ナビゲーションメニューで、Kubernetes Engineに移動します
[コンピューティング]にある[Kubernetes Engine]を選択します
ここでクラスタを作成します
さまざまな設定がありますが、これはKubernetes入門コースではありません
ここでは初めてクラスタを作成するので、デフォルトを受け入れましょう
設定には名前、リージョンがあります
マスターのバージョン、ノードなどを指定できます
すべてデフォルトのままで作成します
ここでの目的は、App Engine、GKE、Cloud Runへのアプリのデプロイ方法を比較することだからです
クラスタが稼働中になったら、クラスタに接続します
Cloud Shellで、コマンドを実行するためです
クラスタが準備されるのを待つ間、ナビゲーションメニューでCompute Engineに移動します
この画面を更新すると、さまざまなノードが作成されて表示されます
それらはCompute Engineインスタンスです
しばらく待ってから更新すると、いくつかのCompute Engineインスタンスが表示されるはずです
もう少し待ってから戻りましょう
Kubernetesクラスタの作成が完了して、稼働中になっています
Compute Engineに戻ると、実際のノードが表示されています
つまり、GKEはCompute EngineのVMをノードとして使用、管理します
前のラボを振り返ると、VMインスタンスでのコンテナの起動は自分で行いました
ここではGKEにすべての処理の管理を任せています
クラスタに接続するために、Kubernetes Engineに戻って[接続]ボタンをクリックします
コマンドラインでクラスタ、ゾーン、プロジェクトを明示的に指定して接続します
[CLOUD SHELLで実行]をクリックするか、コマンドをコピーして既存のCloud Shellセッションに移動してここに貼り付けます
これを実行します
構成されたので、さらにコマンドを実行します
kubectl get nodesです
ノードが一覧されます
表示されたこれらのノードは、Compute Engineにあるものと同じです
次は、このmain.pyファイルに変更を加えます
コードエディタで、“Hello App Engine.”ではなく“Hello Kubernetes Engine.”に変更します
入力したら保存します
クラスタにはまだ何もデプロイしていないので、デプロイします
具体的にはYAML形式の構成ファイルを作成します
developing-apps-to-gcpフォルダ内に作成します
右クリックして[New File]を選択します
“Kubernetes-config.yaml”と名付けます
構成は用意されています
繰り返しますが、このコースの目的はKubernetesの操作方法を学ぶことではなく、デプロイ方法の比較です
スクロールすると構成内容を確認できます
フロントエンド、コンテナ、イメージに関する情報があります
まだイメージはありませんが、作成したらここに指定します
ご覧のように、これはロードバランサがポート80で稼働するHTTPアプリです
このようにYAMLファイルの最初のセクションで構成を指定します
３つのインスタンスをデプロイするので、Pythonウェブアプリのreplicas属性の値は３です
これらはイメージの属性です
詳細については、ラボの手順に記載されているリンクをご覧ください
デプロイの詳細とここに示されている外部ロードバランサの作成方法を確認できます
ここでは、Dockerイメージを作成してビルドする必要があります
そのためには、正しい作業フォルダに移動します
これをコピーします
コマンドgcloud builds submitを実行します
ここでも環境変数のプロジェクトIDを参照します
作成するイメージには、“v0.2”という名前を付けます
これをビルドします
最終的にビルドされたイメージには、実際のプロジェクトID、名前、バージョンが示されます
そのイメージをコピーして、kubernetes-config.yamlファイルに貼り付けます
完成したイメージがここに示されています
これをコピーして、構成ファイル内に貼り付ければ準備完了です
これを保存したら、次はこの構成を適用する必要があります
そのためのコマンドは、ラボの手順に記載されています
kubectl applyの後にYAMLファイルを指定します
Podを調べると３つのレプリカがあるはずです
コンテナが作成中になってから、まだ８秒しか経っていません
すべて作成されて使用可能になるまで、待つ必要があります
クエリを繰り返してステータスを確認できます
20秒後にクエリを実行したところ、すべて稼働中になりました
構成ファイルには、ロードバランサも指定されています
下に移動するとロードバランサを確認できます
実際にこれらのサービスを取得しましょう
ここで外部IPアドレスを確認できます
外部IPアドレスをコピーして、アプリに移動しましょう
このアプリを表示できるかどうかを確認するために新しいタブを開きます
外部IPアドレスを貼り付けて移動します
“Hello Kubernetes Engine.”と表示されました
これでタスク３は完了です
App EngineとGKEが完了したので、残りはあと１つです
Cloud Runに移りましょう
Cloud RunはKubernetesへのデプロイを簡素化して自動化します
Cloud Runでは構成ファイルは不要です
アプリに使用するクラスタを選ぶだけです
使用するクラスタは、Googleが管理するものでも独自のKubernetesクラスタでも構いません
これまでと同じように、main.pyファイルに変更を加えます
次に、今回は新しいDockerイメージを作成します
Cloud Shellに戻ります
App EngineとGKEでは構成ファイルが必要でしたが、ここでは不要です
main.pyに移動して、“Hello Cloud Run.”に変更します
これを保存します
Dockerイメージをビルドしましょう
Cloud Shellでコマンドをいくつか実行し、Cloud Buildでイメージを作成してContainer Registryに保存します
これをクリアします
正しい作業ディレクトリに移動します
ここで、新しいイメージを作成します
完了したら、Cloud Runに移動してそこからサービスを作成します
ビルドが完了してイメージが準備できました
Cloud Runに移動するために、Cloud Consoleのタブに切り替えます
ナビゲーションメニューで、[コンピューティング]から[Cloud Run]を選択します
この例のように、Cloud Runが有効にされていない場合、[Cloud Runの使用を開始する]をクリックしてAPIを有効にします
Cloud Run APIが有効化されています
このパネルを閉じます
これからサービスを作成します
APIが有効になったのでもう一度試します
コンテナイメージを選択します
cloud-run-imageを展開すると、先ほど作成したイメージが表示されます
[続行]をクリックします
他にもさまざまな設定があり、実行場所などを選択できます
すべてのオプションを展開しましょう
最も重要な設定として、[未認証の呼び出しを許可する]をオンにします
公開APIウェブサイトを作成しているからです
他の設定はすべてデフォルトのままで、[作成]をクリックします
このサービスのデプロイには長い時間はかかりません
完了して緑のチェックマークが示されたら、自動生成されたURLをクリックします
このテストで“Hello Cloud Run.”と表示されたら成功です
１、２分でデプロイが完了しました
Kubernetesクラスタほどではありませんが、少々時間がかかります
緑のチェックマークが示されているのでこのURLをクリックします
“Hello Cloud Run.”です
ラボは以上です
