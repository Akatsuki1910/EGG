コンテナ化されたアプリの管理とスケーリングに、役立つプロダクトがKubernetesです
アプリとワークロードのスケーリングの時間と手間を減らすため、KubernetesはGKEを使用してブートストラップできます
Kubernetesとは何でしょうか？
コンテナ化されたワークロードとサービスの管理用の、オープンソースプラットフォームです
複数のホストにおける多数のコンテナのオーケストレーションや、マイクロサービスとしてのスケーリング、ロールアウトとロールバックのデプロイを容易にします
全体像として、Kubernetesは、クラスタと呼ばれるノードのセットにコンテナをデプロイするためのAPIセットです
システムは、コントロールプレーンとして実行される主な要素のセットと、コンテナを実行するノードのセットに分けられます
Kubernetesでは、ノードはマシンなどの演算インスタンスを表します
Compute Engineで実行されるVMを指すGoogle Cloudのノードとは異なります
一連のアプリとアプリ間の通信方法を記述すれば、Kubernetesがその実現方法を決定します
１つ以上のコンテナをラッパーを使って、ノードにデプロイしたものがPodです
PodはKubernetesで作成、デプロイできる最小の単位です
アプリのコンポーネントまたはアプリ全体として、クラスタ上で実行中のプロセスを表します
通常、Podに含まれるコンテナは１つのみですが、強い依存関係を持つ複数のコンテナがあればそれらを１つのPodにパッケージ化して、ネットワーキングとストレージのリソースを共有できます
Podには、コンテナ用の固有のネットワークIPと一連のポートに加え、コンテナの実行方法を指定する構成可能なオプションがあります
Pod内のコンテナを実行する一つの方法は、kubectl runコマンドを使うことです
これはDeploymentを開始し、Pod内でコンテナを実行します
Deploymentは同じPodのレプリカのグループを表し、ノードに障害が起きてもPodの実行を維持します
Deploymentはアプリのコンポーネント、またはアプリ全体を表します
プロジェクトで実行中のPodのリストを見るには、kubectl get podsコマンドを実行します
KubernetesはPodの固定IPアドレスを持つServiceを作成し、コントローラの指示により、パブリックIPアドレスを持つ外部ロードバランサがServiceに接続され、クラスタ外からアクセス可能になります
GKEでは、ロードバランサはネットワークロードバランサとして作成されます
このIPアドレスに到達したクライアントは、Serviceの背後にあるPodにルーティングされます
ServiceはPodの論理的なセットと、Podへのアクセスに使うポリシーを定義する抽象化機能です
Deploymentが作成、破棄するPodには、IPアドレスが割り当てられますが、そのアドレスは安定してはいません
ServiceグループはPodのセットであり、Podに安定したエンドポイント（固定IPアドレス）を提供します
たとえばfrontendとbackendというPodのセットを作成し、それぞれのServiceの背後に置くと、backend Podが変化しても、frontend Podはそれを認識しなくともbackend Serviceを参照することができます
Deploymentをスケーリングするには、kubectl scaleコマンドを実行します
この例ではDeployment内に３つのPodが作成され、Serviceの背後に配置されて１つの固定IPアドレスを共有しています
パラメータを設定して自動スケーリングを使うこともできます
たとえばCPU使用率がしきい値に達すると、Pod数を増やすように指定できます
ここまで、expose、scaleなどの命令型コマンドを実行する方法を見てきました
これはKubernetesの学習とテストに役立ちます
しかしKubernetesの真価は宣言型の方法で使ったときに発揮されます
コマンドを発行する代わりに、目的の状態を記述した構成ファイルを提供すると、Kubernetesが実現方法を決定します
これは、Deployment構成ファイルを使用して行います
このファイルを取得するにはkubectl get podsコマンドを実行します
すると、このようなDeployment構成ファイルが返されます
指定した数のレプリカが実行されていることを確認するには、kubectl get deploymentsまたは、kubectl describe deploymentsを実行します
レプリカを３つから５つに増やすには、Deployment構成ファイルを更新し、kubectl applyコマンドを実行して更新済みの構成ファイルを適用します
kubectl get servicesを使用して、Serviceの外部IPを取得し、クライアントからパブリックIPアドレスにアクセスすると、以前のようにエンドポイントにアクセスできます
最後に考えるのは、アプリを最新バージョンに更新する方法です
コンテナを更新して新しいコードを反映する必要がありますが、すべての変更を一度にロールアウトするのは危険です
この場合、kubectl rolloutを使用するか、Deployment構成ファイルを更新した後にkubectl applyを使用して変更を適用します
すると、更新計画に沿って新しいPodが作成されます
ここに示した構成例では新しいバージョンのPodを個別に作成し、新しいPodが１つ利用可能になった後で古いPodが１つ破棄されます
