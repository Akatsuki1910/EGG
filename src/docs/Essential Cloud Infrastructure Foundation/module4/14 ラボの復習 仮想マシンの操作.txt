このラボでは基本ソフト（ヘッドレスJava Runtime Environment）と、アプリソフト（Minecraftゲームサーバー）をインストールして、独自のVMインスタンスを作成しました
高速SSDを準備してアタッチすることで、VMをカスタマイズし、アドレスが一定になるように静的外部IPアドレスを予約しました
このIPアドレスを使用して、ゲームサーバーの可用性をオンラインで検証しました
次にバックアップシステムを設定して、サーバーのデータをCloud Storageバケットにバックアップしてから、システムをテストしました
またcronを使用して、バックアップを自動化しました
最後にメタデータを使用して、サーバーの起動と停止を正常に行うスクリプトを設定しました
スクリプトの自動化を含むこうした手法の多くは、どのアプリでも本番環境サーバーの管理に応用できます
ラボのチュートリアルは引き続き参照できますが、GCPのUIは変更されることがあるため、実際の環境は見た目が異なる場合があります
[VMインスタンス]でインスタンスの作成を始めましょう
ラボで指定されているプロパティと値をそのまま使用します
名前はmc-server（Minecraftサーバー）です
us-central1-aゾーンに配置します
アクセススコープを、[各APIにアクセス権を設定]に変更します
ストレージは[読み取り専用]ではなく、[読み取り/書き込み]に変更します
これで後で作成するCloud StorageバケットへのVMインスタンスの書き込みが許可されます
このインスタンスのディスクも変更するので、下部のオプションを展開します
[ディスク]で[新しいディスクを追加]をクリックします
名前はminecraft-diskとします
[SSD永続ディスク]を指定します
空のディスクなのでソースはありません
50GBあれば今回の目的には十分です
[暗号化]は[Googleが管理する鍵]のままにします
[完了]をクリックするとディスクが作成されて、自動的にVMにアタッチされます
次は[ネットワーキング]でネットワークタグを追加します
これによって特定のファイアウォールルールを作成できるようになります
タグ名はminecraft-serverとします
[ネットワークインターフェース]で、鉛筆アイコンをクリックして編集します
内部IPはそのままにして外部IPアドレスを作成します
静的IPアドレスを予約するということです
こうすることで、エフェメラルでない不変のIPアドレスになります
名前を付けて、[予約]をクリックします
予約されたら[完了]をクリックして、このインスタンスを作成します
[完了]、[作成]をクリックします
インスタンスが稼働したら、データディスクを準備します
ディレクトリを作成してディスクのフォーマットとマウントを行います
このタブは今は不要なので閉じましょう
インスタンスの稼働を待って[SSH]をクリックし、インスタンスに接続します
まずは、データディスクのマウントポイントとなるディレクトリを作成するために、ラボで指定されているコマンドを使います
その後はディスク自体をフォーマットします
SSH接続が確立されるまで待ちましょう
デフォルトネットワークにSSHのファイアウォールルールがあるため、接続が可能です
それでは、コマンドを実行してディスクをフォーマットしましょう
次にこれをマウントします
このコマンドでは出力が表示されませんが、問題ありません
ここがラボのチェックポイントになりますので、進行状況を確認してください
ここまで順調です
タスク３に進み、アプリをインストールし実行します
Minecraftサーバー自体はJava VM上で実行されるため、Java Runtime Environment（JRE）が必要です
UIは不要なので、ヘッドレスバージョンをインストールします
マシンでのリソース使用量が抑えられるので、Minecraftサーバーのリソース使用量を必要に応じて拡張できる十分な容量が確保されます
まずはリポジトリを更新します
次にヘッドレスJREをインストールします
次に永続ディスクがマウントされている、ディレクトリに移動します
このディレクトリにMinecraft JARファイルをダウンロードします
移動してコマンドを実行します
ダウンロードが行われています
ラボのマニュアルにはダウンロードページに関する情報もあるので、詳細を確認できます
Linuxマシンでの設定方法についても詳しい手順が用意されています
カスタマイズが必要な場合は、リンク先を参照してください
Minecraftサーバーを初期化しましょう
コマンドを実行すると、エンドユーザー使用許諾契約に同意しなければサーバーを実行できないと表示されました
同意します
進行状況で、JREとMinecraftサーバーのインストールが完了していることを確かめてみます
ラボに緑色のチェックマークが表示されました
作成されたファイルを確認して、使用許諾契約を見つけます
ありました
nanoでこれを編集します
最後の行を変更するだけです
falseではなく、trueに設定して使用許諾契約に同意します
変更します
Ctrl+Oを押してファイルに保存し、Enterを押してからCtrl+Xを押して戻ります
Minecraftサーバーの再起動はまだ行いません
後で別の方法を使って行います
次は、サーバーを起動する仮想ターミナルscreenを作成します
そのためにscreenをインストールします
ラボの手順に記載されているコマンドを使います
すでにインストールされているようなので、screenコマンドを使用してサーバーを起動しましょう
実行します
しばらく時間がかかる場合がありますが、環境全体が自動的に構築されます
ご覧のように、worldというレベルの準備や、レシピの読み込みなどこれらはすべてインストール中のゲームアプリに関連する固有のコマンドです
完了するまで待ってから接続を解除して移動します
スポーンエリアが完成したので接続を解除しますが、その前にこの出力の最初に示されている使用ポートを確認しましょう
後でファイアウォールルールを作成して、このポートへのクライアントトラフィックを許可する必要があります
これで接続を解除できます
Ctrl+AとCtrl+Dを押してターミナルを終了します
ターミナルに再接続するコマンドもあります
ここでは再接続せずに終了します
次はクライアントトラフィックを許可するために、ファイアウォールルールを作成します
作成済みのネットワークタグを使います
これは[列]、[ネットワークタグ]で表示できます
ネットワークタグはminecraft-serverです
[VPCネットワーク]の[ファイアウォールルール]に移動します
新しいファイアウォールルールにminecraft-ruleという名前を付けます
適用するのはデフォルトネットワークです
今ある唯一のネットワークです
[指定されたターゲットタグ]でminecraft-serverを指定します
これでこのタグが付いたインスタンスのみにルールが適用されます
IP範囲として全範囲を定義します
プロトコルはTCP専用として、ポートは25565です
[作成]をクリックします
ルールが実行されたらこのサーバーの稼働状態を確認します
戻って、[通知]ペインでプロセスをモニタリングできます
Compute Engineに戻ります
外部IPアドレスがここに表示されています
稼働状態を確認する方法は複数ありますが、HTTPを有効にしていないのでこれをクリックして確認することはできません
HTTPであればTCPのポート80です
ラボの手順に記載されているウェブサイトや、Chrome拡張機能も利用できます
そのChrome拡張機能がここにありますので試してみましょう
[オプション]に移動してIPアドレスを変更し、保存します
確認してみましょう
名前もMy Minecraft Serverに変更して、保存します
ここに表示されるかどうかを確認します
記載されているウェブサイトを使うこともできます
ただしサードパーティ製ツールなので、機能しない場合があることに注意してください
この拡張機能もうまく機能していないようです
表示されませんね
ラボの手順で進行状況を確認すると問題なく進んでいるので、これでタスクは完了です
これらのサードパーティ製ツールではステータスをテストできない場合もあります
もう一つすぐに試せる方法があります
外部IPアドレスをコピーして貼り付け、サーバーのステータスを取得します
ステータスが表示されました
サーバーは稼働しており、現在はプレーヤーがいないことがわかります
実行中の正確なバージョンも表示されています
Chrome拡張機能では失敗しましたが、このページでは確認できました
次に進みましょう
サーバーが稼働していますが、定期バックアップをスケジュールし、サーバーのメンテナンスを行って長期的な計画を立てられるようにします
もう一度サーバーにSSH接続します
Cloud Storageに対する読み取り/書き込みアクセスを許可しているので、Cloud Shellを使用する場合と同じようにサーバーで直接バケットを作成できます
まず初めに独自のバケット名を定義して、環境変数に格納します
export YOUR_BUCKET_NAMEの後に、グローバルに一意の名前を指定します
たとえばプロジェクトIDを使用できます
コピーして、サーバーに戻り、貼り付けます
環境変数を作成する際は、必ずechoコマンドを実行して適切に作成されたことを確認してください
このようになります
次にgsutilコマンドを使います
Cloud Storageでのバケット作成を意味するmbを指定してから、先ほど入力した一意の部分を使い、識別しやすいようにminecraft-backupを追加しておきます
これで判読性が高まります
できました
これがプロジェクト内に作成されていることも確認しましょう
ナビゲーションメニューから、[Storage]に移動すると、バケットを確認できます
ここからもバケットを作成できますが、この方法であればすべてが変数に格納されるので、今後のすべてのバックアップをVMを介して行えます
バックアップスクリプトの作成に進みましょう
Minecraftのホームディレクトリに移動します
nanoを使用して新しいスクリプトを作成します
用意されているスクリプトを貼り付けましょう
バックアップについて記述されたscreenコマンドです
これを貼り付けてCtrl+Oを押します
Enterで保存してCtrl+Xで戻ります
このスクリプトはサーバーのworldの現在の状態を保存し、自動保存機能を一時停止します
次にサーバーのworldデータディレクトリをバックアップし、内容をCloud Storageバケットのタイムスタンプ付きディレクトリに配置します
データのバックアップが完了したら、Minecraftサーバーの自動保存機能を再開します
このスクリプトを実行可能にするために指定コマンドを実行します
これでスクリプトをテストできます
実際にバックアップスクリプトを実行してみます
ファイルがコピーされているのがわかります
確かめてみましょう
作成済みのCloud Storageバケットに移動します
開くとフォルダが表示されます
中を見ればworldの詳細情報を確認できます
バックアップが機能していることがわかりました
バックアップをスケジュールして、自動で実行させることもできます
SSHセッションに戻ってsudo crontabコマンドを実行します
ここでは操作が最も簡単なnanoを選択しますが、他の選択肢もありますのでやりやすい方法を選んでください
一番下で実行の頻度を定義します
これで４時間ごとにバックアップが実行されます
定義方法を確認できるドキュメントもありますが、今回のタスクではそこまで必要ありません
ファイルを保存して終了します
これにより月に約300ものバックアップが作成されることになるので、定期的な削除を検討する必要があります
Cloud Storageのオブジェクトのライフサイクル管理機能なら、オブジェクトの有効期間を設定するだけでなく、古いものを別のストレージクラスにアーカイブすることもできます
詳細についてはシリーズの次のコースで、Cloud Storageを取り上げる際に説明します
ラボで進行状況を確認します
問題ないようです
最後のタスクはメンテナンスの実行です
停止と再起動を行う際には特定のアクションが発生します
sudo screenコマンドを実行します
移動して実際にこのインスタンスを停止します
ナビゲーションメニューで、Compute Engineにアクセスします
サーバーを選択して[停止]をクリックします
確認ダイアログが表示されるので[停止]をクリックします
後で必要に応じて再起動できます
これによりSSHセッションからもログアウトされます
インスタンスが停止するまで待ちましょう
次に起動スクリプトと停止スクリプトで、サーバーのメンテナンスを自動化します
インスタンスが停止したのでクリックします
カスタムメタデータを編集するので、[編集]をクリックします
メタデータまでスクロールします
起動スクリプトと停止スクリプトを定義するので、一般公開されているCloud Storageのファイルを指すように設定します
[キー]はstartup-script-urlで、[値]はファイルの場所です
スペースを広げて、形式が正しいことを確認しましょう
別の項目を追加します
同様に停止スクリプトを定義します
実際にこれらのファイルに移動して、起動スクリプトと停止スクリプトの動作内容を確認することもできます
[保存]をクリックします
サービスを再起動できます
サービスが停止している間に、ステータスページに戻るとステータスを取得できないことが示されているので、サーバーが停止状態であるとわかります
再起動します
起動スクリプトの実行が完了したら、戻ってサービスが実際にアクセス可能になっていることを確認できます
実際のインスタンスの起動には時間がかかることがあります
起動スクリプトが完了して再起動されました
