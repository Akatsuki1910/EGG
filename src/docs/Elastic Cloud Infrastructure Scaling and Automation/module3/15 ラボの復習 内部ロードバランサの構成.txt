このラボではus-central1に、マネージドインスタンスグループを２つ作成し、これらへのHTTPトラフィックとGCPヘルスチェッカーからのTCPトラフィックを許可するファイアウォールルールも作成しました
次にこれらのインスタンスグループの内部ロードバランサを構成、テストしました
ラボのチュートリアルは引き続き参照できますが、GCPのUIは変更されることがあり、実際の環境とは異なる場合があります
これがGCP Consoleです
このラボでは他のラボと同様に、いくつかのリソースが事前に作成されています
[ナビゲーションメニュー]から[Deployment Manager]に移動すれば、これらのリソースを確認できます
ここではデプロイを確認できます
２つのサブネットと、いくつかのファイアウォールルールを持つネットワークを作成しました
[VPCネットワーク]でも同じリソースを確認できます
ラボの手順ではこの方法が紹介されています
ここをクリックします
defaultネットワークがあります
これが追加で作成した２つのサブネットを持つネットワークです
またここにはICMP、SSH、RDPを許可するファイアウォールルールがいくつかあります
ファイアウォールルールをいくつか追加で作成しましょう
HTTPごとに１個ずつ作成してから、ヘルスチェック用にいくつか作成します
[ファイアウォールルールを作成]をクリックします
これはHTTPロードバランサのラボで行った手順と似ています
大きな違いはルールを適用する独自のネットワークがあることです
また[ターゲットタグ]には、lb-backend、[IP範囲]には0.0.0.0/0、HTTPには[tcp]で80を指定します
[作成]をクリックします
次に、同じ手順でヘルスチェッカー用のルールを作成します
ファイアウォールルールの名前をコピーして貼り付け、適切なネットワークを選択します
そして、[ターゲットタグ]にlb-backendを使用します
次に[IP範囲]に範囲を１つずつコピーして貼り付けます
１つ貼り付けたらスペースを追加し、もう１つをコピーして貼り付けます
今回は[tcp]にすべてのポート（all）を指定しますが、ヘルスチェッカーでチェックする対象によっては特定のポートも指定できます
[作成]をクリックします
次にインスタンステンプレートと、インスタンスグループを構成します
[Compute Engine]の[インスタンステンプレート]に移動します
作成するテンプレートの名前は、instance-template-1です
作成ボタンをクリックします
名前はすでに入力されています
次に、[管理、セキュリティ、ディスク、ネットワーキング、単一テナンシー]です
ここで注意点です
HTTPロードバランサにはカスタムイメージがありましたが、今回のケースでは起動スクリプトを設定します
そのため[メタデータ]で、[キー]としてstartup-script-urlを入力します
また起動ファイルは、一般公開されているCloud Storageバケットに配置されています
ラボにあるリンクにアクセスして、起動ファイルを実際に確認できます
[ネットワーキング]に移動し、作成したファイアウォールルールを特定のネットワークタグと特定のネットワークに適用します
適切なネットワークが選択されていることを確認し、[ネットワークタグ]を指定します
[サブネット]でsubnet-aを選択します
[作成]をクリックします
次はsubnet-b用に別のインスタンステンプレートを作成します
作成が終わるまで待ち、そのテンプレートから別のテンプレートを作成します
テンプレートを選択し、[コピー]をクリックします
コピーすると名前は自動的に変更されます
主な違いは別のサブネットを選択する点です
subnet-bを選択し、[作成]をクリックします
テンプレートが更新されたら、マネージドインスタンスグループを作成できます
[インスタンスグループ]に移動し、instance-group-1という名前で１つ目のグループを作成します
[シングルゾーン]を選択し、us-central1-aを指定します
使用するのは、instance-template-1です
[自動スケーリングポリシー]に[CPU使用率]を選択し、[ターゲットのCPU使用率]は80、最小数は１、最大数は５に設定します
[クールダウン期間]もたとえば45秒に変更できます
これで[作成]をクリックできますが、ここでヘルスチェックを添付することも後からロードバランサで添付することもできます
[作成]をクリックして、同じ手順でinstance-group-2を作成します
これはもう一つのグループです
このグループは同じくus-central1にある別のインスタンステンプレートに基づいています
たとえばus-central1-bを指定しましょう
先ほど同じく[ターゲットのCPU使用率]を80、[インスタンスの最大数]を５、[クールダウン期間]を45に変更します
先に進み、このグループも作成します
[VMインスタンス]をクリックすると、１つ目のインスタンスグループのインスタンスがあります
[インスタンスグループ]に戻り、instance-group-1を表示するために更新すると、instance-group-2の別のインスタンスが作成中であることがわかります
再び[VMインスタンス]で作成状況を確認すると、それぞれに１つのインスタンスグループがあります
次は、これらのインスタンスに接続するためユーティリティVMを作成します
ちなみに、内部IPアドレスを確認すると、これらのインスタンスはそれぞれ異なるCIDR範囲の一部であることがわかります
このnic0をクリックすると、どのネットワークインターフェースに属しているかわかります
subnet-aですね
これは合っています
もう一方をクリックすると、subnet-bと表示されます
各サブネット内には現在インスタンスグループがあります
別のインスタンスを作成しましょう
utility-vmです
内部ロードバランサはリージョン単位なので、同じリージョンを使用します
us-central1-fなど別のゾーンも使用できます
専用の極めて小さなマシンが必要です
そして、ネットワークが適切か確認するため、下部にあるこのオプションを開き、[ネットワーキング]でインスタンスが適切なネットワークにあることを確認します
２つのサブネットのうちsubnet-aを選択します
[プライマリ内部IP]をラボのネットワーク図と一致させたい場合は、実際の内部IPを指定できます
したがって[エフェメラル（自動）]ではなく、[エフェメラル（カスタム）]を選択し、そのIPアドレスを入力します
ラボのネットワーク図と一致させる場合の話です
[完了]をクリックしたら、インスタンスを作成します
使用するIPアドレスが、ラボの手順のものと一致していることを確認するよう記載されているのは、これらのIPが使用可能な最初のIPアドレスであるためです
最初のIPと最初から２つ目のIP、最後のIPと最後から２つ目のIPが予約されるため、[内部IP]は.2からはじまり、これは定義した.50になります
ここでutility-vmにSSH接続すると、すべてのcurlコマンドはこれら２つのIPに基づいています
違う場合は、削除すべきインスタンスが他にないかまず確認しましょう
まずは、こちらの最初のIPに対してcurlコマンドを実行します
このコマンドはラボの手順から直接コピーします
これらのインスタンス用に設定したページが表示されました
これは起動スクリプトから直接取得されます
接続元のIPアドレスが表示されます
接続元はutility-vmです
名前には接続先のインスタンスが表示され、そのリージョンとゾーンも表示されます
もう一つのインスタンスに対しても同じ手順を繰り返すと、アドレスは同じですが異なるインスタンスと異なるゾーンが表示されます
これは内部ロードバランサを設定する際に役に立ちます
ロードバランサのIP自体にcurlコマンドを実行し、何回かcurlを繰り返すと、確立したさまざまなバックエンド間をホッピングしていることがわかります
とりあえず画面を閉じます
次に内部ロードバランサを構成します
[ナビゲーションメニュー]、[ネットワークサービス]、[ロードバランシング]の順に移動します
ロードバランサを作成します
[TCP負荷分散]の構成をはじめましょう
これは内部ロードバランサなので、[VM間のみ]を選択すると、[シングルリージョンのみ]に制限されます
内部ロードバランサがリージョン単位であるのは以前説明しました
[続行]をクリックし、名前を付けます
my-ilbという名前にします
次にバックエンドを構成します
これは、us-central1という特定のリージョンにあります
ネットワークにmy-internal-app、インスタンスグループに１つ目のinstance-group-1を選択し、[完了]をクリックします
別のバックエンドとして、instance-group-2を追加し、ここでも[完了]をクリックします
先ほどヘルスチェックを作成しなかったので、ここで作成しましょう
ヘルスチェックの作成に進みます
名前はmy-ilb-health-checkにして、TCPと80にします
そしてこちらの[ヘルス条件]では、バックエンドの[チェック間隔]、[タイムアウト]、[正常しきい値]、[異常しきい値]を定義します
保存して続けましょう
青いチェックマークが表示されれば、設定は完了です
[フロントエンドの構成]をクリックできます
[サブネットワーク]では、ここではsubnet-bを選択します
[内部IP]では、[静的内部IPアドレスを予約]を選択できます
これはmy-ilb-ipという名前にしましょう
また[自動的に割り当てる]ではなく、[ユーザー指定]を選択します
これは内部IPであるためです
ネットワーク図と一致させるために、10.10.30.5を予約します
それからここで[ポート]を80に設定して、ロードバランサの構成を完了します
[完了]をクリックします
[確認と完了]を表示すると、２つのバックエンドと、その自動スケーリングとゾーンを確認できます
フロントエンドそのものと、この内部ロードバランサにアクセスできる正確なIPアドレスも確認できます
[作成]をクリックします
ロードバランサが作成されたら、次の手順に進みます
できました
[更新]をクリックすると、ロードバランサが設定できたことがわかります
IPアドレスは指定済みなので、ここから取得する必要はなく、代わりにCompute Engineのインスタンスに戻り、utility-vmを使用して、ロードバランサのIPに接続します
curlを実行します
バックエンドには起動スクリプトがあるため、対象のインスタンスが定義されています
これで詳しい情報を収集できます
では、IPアドレスに対してcurlを実行します
最初に実行したcurlでは、instance-group-2が表示されました
もう一度実行すると、またinstance-group-2が表示されました
コマンドをさらに何回か実行して、複数の異なるバックエンドが表示されるか確認します
何回か実行したところ、結果は２、２、２、２、２、続けて１、２、２、２、１となりました
したがって確かに複数のバックエンド間で、負荷分散されていることがわかります
ラボは以上です
