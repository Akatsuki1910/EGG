このラボではモジュールを使用してTerraform構成を作成し、GCPインフラのデプロイを自動化しました
Terraformでは構成の変更に応じて、インクリメンタルな実行プランを作成し、構成全体を段階的に構築できます
インスタンスモジュールを使用すると、複数のリソースに対して同じ構成を再利用して、プロパティを入力変数として扱うことができます
作成した構成とモジュールは、今後のデプロイで作業の出発点として使用できます
ラボのチュートリアルの注意点として、GCPのUIが実際の環境とは少し異なる場合があります
GCP Consoleの画面です
最初にTerraformを使用するためのCloud Shell環境を構成します
TerraformはCloud Shellに統合されているので、インストールされているバージョンを確認します
[Cloud Shellをアクティブにする]をクリックして、Cloud Shellを起動します
terraform --versionコマンドを実行して、バージョンを確認します
ここで実行します
これで、現在構成されているバージョンが出力されます
さらに新しいバージョンがあります
ダウンロード方法はラボの手順で説明していますが、12.2以降のバージョンであれば問題なくラボの手順を行えます
そのまま先へ進んで、フォルダを設定します
その後、コードエディタを起動します
上の鉛筆アイコンで起動できます
コードエディタを使って、作成したばかりのフォルダ内にこれから作成するすべてのファイルを配置します
nanoなどのコマンドラインエディタよりもインタラクティブに操作できます
起動を待つ間に、これをクリアします
まずprovider.tfというファイルを作成し、Terraformを初期化できるようにします
Terraformはプラグインを使用して各種のインフラとサービスプロバイダに対応します
そのためproviderファイルにGoogleをプロバイダとして指定します
tfinfraを右クリックしてprovider.tfなどの新規ファイルを作成します
そこにプロバイダをGoogleに指定したプロパティをコピーします
これを保存します
自動保存が有効なので、毎回[保存]をクリックする必要はありません
次はCloud Shell内で先ほど作成したフォルダに移動します
ここでterraform initコマンドを実行します
これでプロバイダが初期化されて、ここでプロバイダとバージョンを確認できます
初期化されたので、TerraformとCloud Shellを操作できます
最初にネットワークを構成するために新しいファイルを作成します
このフォルダ内に“mynetwork.tf”を作成します
ここに、ラボの手順に記載されている基本コードをコピーします
まずコメントがあります
続いてリソースタイプとリソース名があります
リソースのプロパティも使用できます
基本テンプレートは、GCPのどのリソースでも構成の出発点として大いに役立ちます
nameフィールド、typeフィールドやプロパティを使用して、各リソースの詳細を定義します
まずすべきこととして、タイプを“google_compute_network”に置き換えます
ここで重要な点として、定義するすべてのリソースを引用符で囲んでください
これはVPCネットワークです
詳細についてはラボにある２つのドキュメントリンクで確認できます
１つはGCPドキュメント、もう１つはTerraformドキュメントのリンクです
名前も置き換えます
リソース名を“mynetwork”に置き換えて引用符で囲みます
次はプロパティを作成します
これを自動モードネットワークにして、サブネットが自動作成されるようにします
このように定義します
プロパティを省略可能なリソースもありますが、この場合は“auto_create_subnetworks”を“true”に定義する必要があります
この時点で、ファイルの内容がラボと一致することを確認します
一致しています
いくつかのプロパティが移動されて間隔が取られていますが、後で実行するコマンドで自動処理されるので現時点では特に問題ありません
これを保存します
次は、ファイアウォールルールを構成します
この場合も基本コードがあるので、ネットワークリソースの下に貼り付けます
このファイアウォールルールでは、HTTP、SSH、RDP、ICMPを許可します
正しいタイプを確認する必要があります
Terraformドキュメントでも確認できますが、ラボの手順の“google_compute_firewall”を使用できます
これも引用符で囲む必要があります
この２つの間にスペースを入れます
名前も指定します
これがファイアウォールルールの名前になります
これを作成すると、GCP内でこの名前が表示されます
いくつかのリソースプロパティを指定する必要があります
ファイアウォールルールに重要なのは、ルールの適用対象のネットワーク、送信元IPの範囲、プロトコルとポートのプロパティです
送信元IPの範囲を定義しなければ、“0.0.0/0”に設定されます
この例では特定のネットワークを定義します
それを貼り付けます
このファイアウォールルールはこのネットワークに依存するため、ここでselfLink参照を使用します
これによりTerraformにリソースを依存順序で解決するように指示します
こうするとネットワークの作成後でないと、ファイアウォールルールを作成できません
VMインスタンスを作成するときも同じようにします
さらに別のプロパティを追加して、特定のプロトコルとポートの組み合わせを許可します
具体的には、SSHにはTCP22を許可し、HTTPには80、RDPには3389、そしてICMPプロトコル全体を許可します
これで、手順の内容と一致することを確認できます
一致しているので[Save]で保存しますが、実際には自動保存されているので[Save]をクリックする必要はありません
次はVMインスタンスを構成します
それにはインスタンスモジュールを作成し、再利用可能な構成としてフォルダ内に格納します
つまり１つのモジュールを作成して、これから作成する両方のインスタンスに使います
まずモジュール用のフォルダを作成します
tfinfraフォルダ内に新しいフォルダを作成して、その名前を“instance”に設定します
tfinfraフォルダの外側に作成されたので、ドラッグして移動します
右クリックでも作成できます
ラボにこれらのフォルダの階層が示されています
このフォルダ内にファイルを作成し、“maintf”と名付けます
続いてこのファイル内にも出発点となる基本コードを貼り付けます
リソースタイプとリソース名を設定します
タイプは“google_compute_instance”です
置き換えて引用符で囲みます
名前についてはハードコードして指定するのではなく、変数を使用します
異なる名前で複数のインスタンスを作成できるようにするためです
名前をこの構造体に置き換えて、このモジュールが適用されるように後で親となる構成を定義します
プロパティとしてゾーンとマシンタイプも追加します
ここでも変数を使用するので、変数を定義します
ブートディスクも追加します
もう１つのブートディスクもハードコードします
イメージを指定して、作成するすべてのインスタンスで使用されるようにします
ネットワークインターフェースも追加します
インスタンスを実行するサブネットを定義する必要があります
この構造体をここに配置することで、外部IPアドレスつまりパブリックIPアドレスがインスタンスに割り当てられます
次は入力変数を定義する必要があります
名前、ゾーン、タイプ、サブネットワークには入力変数を使用するからです
“resource”の上にコードを追加します
ここに追加する変数は、名前とゾーンの変数です
インスタンスタイプも定義します
これらのかっこの中に値を指定すると、それがデフォルト値になります
別の値を入力しなければこの構成で指定されたタイプが使用されます
これは一種のデフォルトとして役立ちます
イメージも同様に処理して、入力変数を使用してイメージを制御できるようにします
この時点で構成を確認します
モジュールと呼ぶべきこの構成はラボの手順と同じようになっています
これで作業を進めるために保存できます
次に必要な作業は、定義したモジュールを構成内で使用することです
ネットワークとファイアウォールルールの他に、VMインスタンスの作成とそれに使用する入力変数、これが使用すべきモジュールであることを指定します
ラボの手順からコピーしてここに貼り付け、モジュールを定義し、名前を付けます
そしてinstanceフォルダ内にあるソースを定義します
４つの入力変数のうちの３つを指定します
残りの１つにはデフォルト値が設定済みです
ここでもselfLink参照を使うことが重要です
ネットワークの作成後でないとインスタンスもファイアウォールルールも作成できません
ネットワークの作成後は、この後わかるようにこれらのリソースが並行して作成されます
作業を進めて、Cloud Shellですべてをセットアップしましょう
これをクリーンアップします
terraform fmtコマンドを実行し、これらのファイルを再作成して正規の形式とスタイルにします
これにより、すべてのインデントが微調整されます
これは重要なことではなく、mynetwork.tfファイルを処理したことを示しているだけです
エラーが表示されたら、これまで構成した内容と同じであることを確認してください
また、この構成をmynetworkドメインを提供する３つのtsファイルすべてにリンクします
ラボの手順でこれらのファイルを参照して、自分の構成が同じでない場合は違っている部分を修正できます
terraform initコマンドを再実行し、作成したモジュールを使って初期化されるようにする必要があります
初期化されました
次は構成の実行プランを作成します
このコマンドを実行すると、何が作成されるのかを確認するためです
terraform planコマンドを実行すると、作成されるリソースが出力されます
入力される値は多数ありますが、一部の値はリソースが作成されてからでないとわかりません
具体的には４つのものが追加されます
VPCネットワーク、ファイアウォールルール、２つのインスタンスです
問題なければterraform applyコマンドを実行できます
実際には同じ処理が繰り返されますが、実行してよいか尋ねられるので“yes”と入力して、リソースの作成を開始します
最初に作成されるリソースはネットワークです
ネットワークが作成されると、他のすべてのリソースが並行して作成されます
最新の状況が10秒ごとに報告されます
まだ処理中ですね
このように、問題なく処理が進んでいることを確認できます
処理の完了を待ってから、戻って確認しましょう
すべてのリソースが作成されました
最初にネットワークが作成されて、続いてインスタンスの１つと、ファイアウォールルール、もう一方のインスタンスの作成が開始されました
インスタンスはもう作成されたので、後はファイアウォールルールを待つだけです
これらのインスタンスが実際に作成されたことをGCP Consoleに戻って確認しましょう
タブを切り替えます
ナビゲーションメニューで、まず[VPCネットワーク]に移動します
どのネットワークにも既定でデフォルトネットワークがあります
ここに、自動モードネットワークとして作成したmynetworkがあります
[ファイアウォールルール]に移動すると、作成されたカスタムルールと非デフォルトのファイアウォールを確認できます
このルールにより同一ネットワーク内のインスタンスは互いにpingできるはずです
ICMPトラフィックを許可したので、外部IPアドレスでpingできるはずです
同じネットワーク内にあるので、内部IPアドレスでもpingできます
確認のためにナビゲーションメニューで、[Compute Engine]に移動します
最初のVMのIPアドレスをグラブします
もう一方のVMにSSH接続して、最初のインスタンスに対してpingを実行してみます
IPアドレスに対してpingを３回実行します
すべてのパケットが正常に送信されました
両方のVMインスタンスは同じネットワーク内にあり、ファイアウォールルールでICMPトラフィックを許可したからです
以上で終了です
